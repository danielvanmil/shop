///<reference path="./jaydata.d.ts" />
/*//////////////////////////////////////////////////////////////////////////////////////
////// Autogenerated by JaySvcUtil.exe http://JayData.org for more info        /////////
//////                      oData V2 TypeScript                                /////////
//////////////////////////////////////////////////////////////////////////////////////*/


declare module ArticlesViewModel_1 {
  class articles extends $data.Entity {
    constructor ();
    constructor (initData: { ﻿Id?: string; WholesalerId?: string; Listprice?: string; Deliverytime?: string; MaxBoDays?: string; Fillingrate?: string; Mechanical?: string; Stock?: string; FrDtType?: string; SortcodeId?: string; GenreId?: string; Artist?: string; Title?: string; Eancode?: string; MajorId?: string; OriginId?: string; MediaId?: string; SubmediaId?: string; LabelId?: string; LanguageId?: string; StatuscodeId?: string; Suffix?: string; Infoline?: string; Prefix?: string; Releasedate?: string; Activated?: string; Units?: string; Eanpref?: string; });
    ﻿Id: string;
    WholesalerId: string;
    Listprice: string;
    Deliverytime: string;
    MaxBoDays: string;
    Fillingrate: string;
    Mechanical: string;
    Stock: string;
    FrDtType: string;
    SortcodeId: string;
    GenreId: string;
    Artist: string;
    Title: string;
    Eancode: string;
    MajorId: string;
    OriginId: string;
    MediaId: string;
    SubmediaId: string;
    LabelId: string;
    LanguageId: string;
    StatuscodeId: string;
    Suffix: string;
    Infoline: string;
    Prefix: string;
    Releasedate: string;
    Activated: string;
    Units: string;
    Eanpref: string;
    
  }

  export interface articlesQueryable extends $data.Queryable {
    filter(predicate:(it: ArticlesViewModel_1.articles) => boolean): ArticlesViewModel_1.articlesQueryable;
    filter(predicate:(it: ArticlesViewModel_1.articles) => boolean, thisArg: any): ArticlesViewModel_1.articlesQueryable;

    map(projection: (it: ArticlesViewModel_1.articles) => any): ArticlesViewModel_1.articlesQueryable;

    length(): $data.IPromise;
    length(handler: (result: number) => void): $data.IPromise;
    length(handler: { success?: (result: number) => void; error?: (result: any) => void; }): $data.IPromise;

    forEach(handler: (it: ArticlesViewModel_1.articles) => void ): $data.IPromise;
    
    toArray(): $data.IPromise;
    toArray(handler: (result: ArticlesViewModel_1.articles[]) => void): $data.IPromise;
    toArray(handler: { success?: (result: ArticlesViewModel_1.articles[]) => void; error?: (result: any) => void; }): $data.IPromise;

    single(predicate: (it: ArticlesViewModel_1.articles, params?: any) => boolean, params?: any, handler?: (result: ArticlesViewModel_1.articles) => void): $data.IPromise;
    single(predicate: (it: ArticlesViewModel_1.articles, params?: any) => boolean, params?: any, handler?: { success?: (result: ArticlesViewModel_1.articles[]) => void; error?: (result: any) => void; }): $data.IPromise;

    take(amout: number): ArticlesViewModel_1.articlesQueryable;
    skip(amout: number): ArticlesViewModel_1.articlesQueryable;

    order(selector: string): ArticlesViewModel_1.articlesQueryable;
    orderBy(predicate: (it: ArticlesViewModel_1.articles) => any): ArticlesViewModel_1.articlesQueryable;
    orderByDescending(predicate: (it: ArticlesViewModel_1.articles) => any): ArticlesViewModel_1.articlesQueryable;
    
    first(predicate: (it: ArticlesViewModel_1.articles, params?: any) => boolean, params?: any, handler?: (result: ArticlesViewModel_1.articles) => void): $data.IPromise;
    first(predicate: (it: ArticlesViewModel_1.articles, params?: any) => boolean, params?: any, handler?: { success?: (result: ArticlesViewModel_1.articles[]) => void; error?: (result: any) => void; }): $data.IPromise;
    
    include(selector: string): ArticlesViewModel_1.articlesQueryable;

    removeAll(): $data.IPromise;
    removeAll(handler: (count: number) => void): $data.IPromise;
    removeAll(handler: { success?: (result: number) => void; error?: (result: any) => void; }): $data.IPromise;
  }


  export interface articlesSet extends articlesQueryable {
    add(initData: { ﻿Id?: string; WholesalerId?: string; Listprice?: string; Deliverytime?: string; MaxBoDays?: string; Fillingrate?: string; Mechanical?: string; Stock?: string; FrDtType?: string; SortcodeId?: string; GenreId?: string; Artist?: string; Title?: string; Eancode?: string; MajorId?: string; OriginId?: string; MediaId?: string; SubmediaId?: string; LabelId?: string; LanguageId?: string; StatuscodeId?: string; Suffix?: string; Infoline?: string; Prefix?: string; Releasedate?: string; Activated?: string; Units?: string; Eanpref?: string; }): ArticlesViewModel_1.articles;
    add(item: ArticlesViewModel_1.articles): ArticlesViewModel_1.articles;

    attach(item: ArticlesViewModel_1.articles): void;
    attach(item: { ﻿Id: string; }): void;
    attachOrGet(item: ArticlesViewModel_1.articles): ArticlesViewModel_1.articles;
    attachOrGet(item: { ﻿Id: string; }): ArticlesViewModel_1.articles;

    detach(item: ArticlesViewModel_1.articles): void;
    detach(item: { ﻿Id: string; }): void;

    remove(item: ArticlesViewModel_1.articles): void;
    remove(item: { ﻿Id: string; }): void;
    
    elementType: new (initData: { ﻿Id?: string; WholesalerId?: string; Listprice?: string; Deliverytime?: string; MaxBoDays?: string; Fillingrate?: string; Mechanical?: string; Stock?: string; FrDtType?: string; SortcodeId?: string; GenreId?: string; Artist?: string; Title?: string; Eancode?: string; MajorId?: string; OriginId?: string; MediaId?: string; SubmediaId?: string; LabelId?: string; LanguageId?: string; StatuscodeId?: string; Suffix?: string; Infoline?: string; Prefix?: string; Releasedate?: string; Activated?: string; Units?: string; Eanpref?: string; }) => ArticlesViewModel_1.articles;
  }

  export class ArticlesViewModel_1 extends $data.EntityContext {
    onReady(handler: (context: ArticlesViewModel_1) => void): $data.IPromise;
    articles: ArticlesViewModel_1.articlesSet;
    
  }
}

declare module GenresSourceModel {
  export class GenresSourceModel extends $data.EntityContext {
    onReady(handler: (context: GenresSourceModel) => void): $data.IPromise;
    invokeHttp: (action: string, request: $data.Blob, endpoint: string, stream: boolean, result: $data.Blob, contentType: string, headers: $data.Blob, handler?: () => void) => $data.IPromise;
    
  }
}

declare module ArticlesSourceModel {
  export class ArticlesSourceModel extends $data.EntityContext {
    onReady(handler: (context: ArticlesSourceModel) => void): $data.IPromise;
    invokeHttp: (action: string, request: $data.Blob, endpoint: string, stream: boolean, result: $data.Blob, contentType: string, headers: $data.Blob, handler?: () => void) => $data.IPromise;
    
  }
}

declare module GenresViewModel {
  class genres extends $data.Entity {
    constructor ();
    constructor (initData: { Id?: string; WholesalerId?: string; MainGenre?: string; Description?: string; });
    Id: string;
    WholesalerId: string;
    MainGenre: string;
    Description: string;
    
  }

  export interface genresQueryable extends $data.Queryable {
    filter(predicate:(it: GenresViewModel.genres) => boolean): GenresViewModel.genresQueryable;
    filter(predicate:(it: GenresViewModel.genres) => boolean, thisArg: any): GenresViewModel.genresQueryable;

    map(projection: (it: GenresViewModel.genres) => any): GenresViewModel.genresQueryable;

    length(): $data.IPromise;
    length(handler: (result: number) => void): $data.IPromise;
    length(handler: { success?: (result: number) => void; error?: (result: any) => void; }): $data.IPromise;

    forEach(handler: (it: GenresViewModel.genres) => void ): $data.IPromise;
    
    toArray(): $data.IPromise;
    toArray(handler: (result: GenresViewModel.genres[]) => void): $data.IPromise;
    toArray(handler: { success?: (result: GenresViewModel.genres[]) => void; error?: (result: any) => void; }): $data.IPromise;

    single(predicate: (it: GenresViewModel.genres, params?: any) => boolean, params?: any, handler?: (result: GenresViewModel.genres) => void): $data.IPromise;
    single(predicate: (it: GenresViewModel.genres, params?: any) => boolean, params?: any, handler?: { success?: (result: GenresViewModel.genres[]) => void; error?: (result: any) => void; }): $data.IPromise;

    take(amout: number): GenresViewModel.genresQueryable;
    skip(amout: number): GenresViewModel.genresQueryable;

    order(selector: string): GenresViewModel.genresQueryable;
    orderBy(predicate: (it: GenresViewModel.genres) => any): GenresViewModel.genresQueryable;
    orderByDescending(predicate: (it: GenresViewModel.genres) => any): GenresViewModel.genresQueryable;
    
    first(predicate: (it: GenresViewModel.genres, params?: any) => boolean, params?: any, handler?: (result: GenresViewModel.genres) => void): $data.IPromise;
    first(predicate: (it: GenresViewModel.genres, params?: any) => boolean, params?: any, handler?: { success?: (result: GenresViewModel.genres[]) => void; error?: (result: any) => void; }): $data.IPromise;
    
    include(selector: string): GenresViewModel.genresQueryable;

    removeAll(): $data.IPromise;
    removeAll(handler: (count: number) => void): $data.IPromise;
    removeAll(handler: { success?: (result: number) => void; error?: (result: any) => void; }): $data.IPromise;
  }


  export interface genresSet extends genresQueryable {
    add(initData: { Id?: string; WholesalerId?: string; MainGenre?: string; Description?: string; }): GenresViewModel.genres;
    add(item: GenresViewModel.genres): GenresViewModel.genres;

    attach(item: GenresViewModel.genres): void;
    attach(item: { Id: string; }): void;
    attachOrGet(item: GenresViewModel.genres): GenresViewModel.genres;
    attachOrGet(item: { Id: string; }): GenresViewModel.genres;

    detach(item: GenresViewModel.genres): void;
    detach(item: { Id: string; }): void;

    remove(item: GenresViewModel.genres): void;
    remove(item: { Id: string; }): void;
    
    elementType: new (initData: { Id?: string; WholesalerId?: string; MainGenre?: string; Description?: string; }) => GenresViewModel.genres;
  }

  export class GenresViewModel extends $data.EntityContext {
    onReady(handler: (context: GenresViewModel) => void): $data.IPromise;
    genres: GenresViewModel.genresSet;
    
  }
}

declare module SYS {
  class Columns extends $data.Entity {
    constructor ();
    constructor (initData: { VDBName?: string; SchemaName?: string; TableName?: string; Name?: string; Position?: number; NameInSource?: string; DataType?: string; Scale?: number; Length?: number; IsLengthFixed?: boolean; SupportsSelect?: boolean; SupportsUpdates?: boolean; IsCaseSensitive?: boolean; IsSigned?: boolean; IsCurrency?: boolean; IsAutoIncremented?: boolean; NullType?: string; MinRange?: string; MaxRange?: string; DistinctCount?: number; NullCount?: number; SearchType?: string; Format?: string; DefaultValue?: string; JavaClass?: string; Precision?: number; CharOctetLength?: number; Radix?: number; UID?: string; Description?: string; OID?: number; Tables?: SYS.Tables; DataTypes?: SYS.DataTypes; });
    VDBName: string;
    SchemaName: string;
    TableName: string;
    Name: string;
    Position: number;
    NameInSource: string;
    DataType: string;
    Scale: number;
    Length: number;
    IsLengthFixed: boolean;
    SupportsSelect: boolean;
    SupportsUpdates: boolean;
    IsCaseSensitive: boolean;
    IsSigned: boolean;
    IsCurrency: boolean;
    IsAutoIncremented: boolean;
    NullType: string;
    MinRange: string;
    MaxRange: string;
    DistinctCount: number;
    NullCount: number;
    SearchType: string;
    Format: string;
    DefaultValue: string;
    JavaClass: string;
    Precision: number;
    CharOctetLength: number;
    Radix: number;
    UID: string;
    Description: string;
    OID: number;
    Tables: SYS.Tables;
    DataTypes: SYS.DataTypes;
    
  }

  export interface ColumnsQueryable extends $data.Queryable {
    filter(predicate:(it: SYS.Columns) => boolean): SYS.ColumnsQueryable;
    filter(predicate:(it: SYS.Columns) => boolean, thisArg: any): SYS.ColumnsQueryable;

    map(projection: (it: SYS.Columns) => any): SYS.ColumnsQueryable;

    length(): $data.IPromise;
    length(handler: (result: number) => void): $data.IPromise;
    length(handler: { success?: (result: number) => void; error?: (result: any) => void; }): $data.IPromise;

    forEach(handler: (it: SYS.Columns) => void ): $data.IPromise;
    
    toArray(): $data.IPromise;
    toArray(handler: (result: SYS.Columns[]) => void): $data.IPromise;
    toArray(handler: { success?: (result: SYS.Columns[]) => void; error?: (result: any) => void; }): $data.IPromise;

    single(predicate: (it: SYS.Columns, params?: any) => boolean, params?: any, handler?: (result: SYS.Columns) => void): $data.IPromise;
    single(predicate: (it: SYS.Columns, params?: any) => boolean, params?: any, handler?: { success?: (result: SYS.Columns[]) => void; error?: (result: any) => void; }): $data.IPromise;

    take(amout: number): SYS.ColumnsQueryable;
    skip(amout: number): SYS.ColumnsQueryable;

    order(selector: string): SYS.ColumnsQueryable;
    orderBy(predicate: (it: SYS.Columns) => any): SYS.ColumnsQueryable;
    orderByDescending(predicate: (it: SYS.Columns) => any): SYS.ColumnsQueryable;
    
    first(predicate: (it: SYS.Columns, params?: any) => boolean, params?: any, handler?: (result: SYS.Columns) => void): $data.IPromise;
    first(predicate: (it: SYS.Columns, params?: any) => boolean, params?: any, handler?: { success?: (result: SYS.Columns[]) => void; error?: (result: any) => void; }): $data.IPromise;
    
    include(selector: string): SYS.ColumnsQueryable;

    removeAll(): $data.IPromise;
    removeAll(handler: (count: number) => void): $data.IPromise;
    removeAll(handler: { success?: (result: number) => void; error?: (result: any) => void; }): $data.IPromise;
  }


  export interface ColumnsSet extends ColumnsQueryable {
    add(initData: { VDBName?: string; SchemaName?: string; TableName?: string; Name?: string; Position?: number; NameInSource?: string; DataType?: string; Scale?: number; Length?: number; IsLengthFixed?: boolean; SupportsSelect?: boolean; SupportsUpdates?: boolean; IsCaseSensitive?: boolean; IsSigned?: boolean; IsCurrency?: boolean; IsAutoIncremented?: boolean; NullType?: string; MinRange?: string; MaxRange?: string; DistinctCount?: number; NullCount?: number; SearchType?: string; Format?: string; DefaultValue?: string; JavaClass?: string; Precision?: number; CharOctetLength?: number; Radix?: number; UID?: string; Description?: string; OID?: number; Tables?: SYS.Tables; DataTypes?: SYS.DataTypes; }): SYS.Columns;
    add(item: SYS.Columns): SYS.Columns;

    attach(item: SYS.Columns): void;
    attach(item: { VDBName: string; SchemaName: string; TableName: string; Name: string; }): void;
    attachOrGet(item: SYS.Columns): SYS.Columns;
    attachOrGet(item: { VDBName: string; SchemaName: string; TableName: string; Name: string; }): SYS.Columns;

    detach(item: SYS.Columns): void;
    detach(item: { VDBName: string; SchemaName: string; TableName: string; Name: string; }): void;

    remove(item: SYS.Columns): void;
    remove(item: { VDBName: string; SchemaName: string; TableName: string; Name: string; }): void;
    
    elementType: new (initData: { VDBName?: string; SchemaName?: string; TableName?: string; Name?: string; Position?: number; NameInSource?: string; DataType?: string; Scale?: number; Length?: number; IsLengthFixed?: boolean; SupportsSelect?: boolean; SupportsUpdates?: boolean; IsCaseSensitive?: boolean; IsSigned?: boolean; IsCurrency?: boolean; IsAutoIncremented?: boolean; NullType?: string; MinRange?: string; MaxRange?: string; DistinctCount?: number; NullCount?: number; SearchType?: string; Format?: string; DefaultValue?: string; JavaClass?: string; Precision?: number; CharOctetLength?: number; Radix?: number; UID?: string; Description?: string; OID?: number; Tables?: SYS.Tables; DataTypes?: SYS.DataTypes; }) => SYS.Columns;
  }

  class DataTypes extends $data.Entity {
    constructor ();
    constructor (initData: { Name?: string; IsStandard?: boolean; IsPhysical?: boolean; TypeName?: string; JavaClass?: string; Scale?: number; TypeLength?: number; NullType?: string; IsSigned?: boolean; IsAutoIncremented?: boolean; IsCaseSensitive?: boolean; Precision?: number; Radix?: number; SearchType?: string; UID?: string; RuntimeType?: string; BaseType?: string; Description?: string; OID?: number; Columns?: SYS.Columns[]; ProcedureParams?: SYS.ProcedureParams[]; });
    Name: string;
    IsStandard: boolean;
    IsPhysical: boolean;
    TypeName: string;
    JavaClass: string;
    Scale: number;
    TypeLength: number;
    NullType: string;
    IsSigned: boolean;
    IsAutoIncremented: boolean;
    IsCaseSensitive: boolean;
    Precision: number;
    Radix: number;
    SearchType: string;
    UID: string;
    RuntimeType: string;
    BaseType: string;
    Description: string;
    OID: number;
    Columns: SYS.Columns[];
    ProcedureParams: SYS.ProcedureParams[];
    
  }

  export interface DataTypesQueryable extends $data.Queryable {
    filter(predicate:(it: SYS.DataTypes) => boolean): SYS.DataTypesQueryable;
    filter(predicate:(it: SYS.DataTypes) => boolean, thisArg: any): SYS.DataTypesQueryable;

    map(projection: (it: SYS.DataTypes) => any): SYS.DataTypesQueryable;

    length(): $data.IPromise;
    length(handler: (result: number) => void): $data.IPromise;
    length(handler: { success?: (result: number) => void; error?: (result: any) => void; }): $data.IPromise;

    forEach(handler: (it: SYS.DataTypes) => void ): $data.IPromise;
    
    toArray(): $data.IPromise;
    toArray(handler: (result: SYS.DataTypes[]) => void): $data.IPromise;
    toArray(handler: { success?: (result: SYS.DataTypes[]) => void; error?: (result: any) => void; }): $data.IPromise;

    single(predicate: (it: SYS.DataTypes, params?: any) => boolean, params?: any, handler?: (result: SYS.DataTypes) => void): $data.IPromise;
    single(predicate: (it: SYS.DataTypes, params?: any) => boolean, params?: any, handler?: { success?: (result: SYS.DataTypes[]) => void; error?: (result: any) => void; }): $data.IPromise;

    take(amout: number): SYS.DataTypesQueryable;
    skip(amout: number): SYS.DataTypesQueryable;

    order(selector: string): SYS.DataTypesQueryable;
    orderBy(predicate: (it: SYS.DataTypes) => any): SYS.DataTypesQueryable;
    orderByDescending(predicate: (it: SYS.DataTypes) => any): SYS.DataTypesQueryable;
    
    first(predicate: (it: SYS.DataTypes, params?: any) => boolean, params?: any, handler?: (result: SYS.DataTypes) => void): $data.IPromise;
    first(predicate: (it: SYS.DataTypes, params?: any) => boolean, params?: any, handler?: { success?: (result: SYS.DataTypes[]) => void; error?: (result: any) => void; }): $data.IPromise;
    
    include(selector: string): SYS.DataTypesQueryable;

    removeAll(): $data.IPromise;
    removeAll(handler: (count: number) => void): $data.IPromise;
    removeAll(handler: { success?: (result: number) => void; error?: (result: any) => void; }): $data.IPromise;
  }


  export interface DataTypesSet extends DataTypesQueryable {
    add(initData: { Name?: string; IsStandard?: boolean; IsPhysical?: boolean; TypeName?: string; JavaClass?: string; Scale?: number; TypeLength?: number; NullType?: string; IsSigned?: boolean; IsAutoIncremented?: boolean; IsCaseSensitive?: boolean; Precision?: number; Radix?: number; SearchType?: string; UID?: string; RuntimeType?: string; BaseType?: string; Description?: string; OID?: number; Columns?: SYS.Columns[]; ProcedureParams?: SYS.ProcedureParams[]; }): SYS.DataTypes;
    add(item: SYS.DataTypes): SYS.DataTypes;

    attach(item: SYS.DataTypes): void;
    attach(item: { Name: string; }): void;
    attachOrGet(item: SYS.DataTypes): SYS.DataTypes;
    attachOrGet(item: { Name: string; }): SYS.DataTypes;

    detach(item: SYS.DataTypes): void;
    detach(item: { Name: string; }): void;

    remove(item: SYS.DataTypes): void;
    remove(item: { Name: string; }): void;
    
    elementType: new (initData: { Name?: string; IsStandard?: boolean; IsPhysical?: boolean; TypeName?: string; JavaClass?: string; Scale?: number; TypeLength?: number; NullType?: string; IsSigned?: boolean; IsAutoIncremented?: boolean; IsCaseSensitive?: boolean; Precision?: number; Radix?: number; SearchType?: string; UID?: string; RuntimeType?: string; BaseType?: string; Description?: string; OID?: number; Columns?: SYS.Columns[]; ProcedureParams?: SYS.ProcedureParams[]; }) => SYS.DataTypes;
  }

  class KeyColumns extends $data.Entity {
    constructor ();
    constructor (initData: { VDBName?: string; SchemaName?: string; TableName?: string; Name?: string; KeyName?: string; KeyType?: string; RefKeyUID?: string; UID?: string; Position?: number; OID?: number; Tables?: SYS.Tables; });
    VDBName: string;
    SchemaName: string;
    TableName: string;
    Name: string;
    KeyName: string;
    KeyType: string;
    RefKeyUID: string;
    UID: string;
    Position: number;
    OID: number;
    Tables: SYS.Tables;
    
  }

  export interface KeyColumnsQueryable extends $data.Queryable {
    filter(predicate:(it: SYS.KeyColumns) => boolean): SYS.KeyColumnsQueryable;
    filter(predicate:(it: SYS.KeyColumns) => boolean, thisArg: any): SYS.KeyColumnsQueryable;

    map(projection: (it: SYS.KeyColumns) => any): SYS.KeyColumnsQueryable;

    length(): $data.IPromise;
    length(handler: (result: number) => void): $data.IPromise;
    length(handler: { success?: (result: number) => void; error?: (result: any) => void; }): $data.IPromise;

    forEach(handler: (it: SYS.KeyColumns) => void ): $data.IPromise;
    
    toArray(): $data.IPromise;
    toArray(handler: (result: SYS.KeyColumns[]) => void): $data.IPromise;
    toArray(handler: { success?: (result: SYS.KeyColumns[]) => void; error?: (result: any) => void; }): $data.IPromise;

    single(predicate: (it: SYS.KeyColumns, params?: any) => boolean, params?: any, handler?: (result: SYS.KeyColumns) => void): $data.IPromise;
    single(predicate: (it: SYS.KeyColumns, params?: any) => boolean, params?: any, handler?: { success?: (result: SYS.KeyColumns[]) => void; error?: (result: any) => void; }): $data.IPromise;

    take(amout: number): SYS.KeyColumnsQueryable;
    skip(amout: number): SYS.KeyColumnsQueryable;

    order(selector: string): SYS.KeyColumnsQueryable;
    orderBy(predicate: (it: SYS.KeyColumns) => any): SYS.KeyColumnsQueryable;
    orderByDescending(predicate: (it: SYS.KeyColumns) => any): SYS.KeyColumnsQueryable;
    
    first(predicate: (it: SYS.KeyColumns, params?: any) => boolean, params?: any, handler?: (result: SYS.KeyColumns) => void): $data.IPromise;
    first(predicate: (it: SYS.KeyColumns, params?: any) => boolean, params?: any, handler?: { success?: (result: SYS.KeyColumns[]) => void; error?: (result: any) => void; }): $data.IPromise;
    
    include(selector: string): SYS.KeyColumnsQueryable;

    removeAll(): $data.IPromise;
    removeAll(handler: (count: number) => void): $data.IPromise;
    removeAll(handler: { success?: (result: number) => void; error?: (result: any) => void; }): $data.IPromise;
  }


  export interface KeyColumnsSet extends KeyColumnsQueryable {
    add(initData: { VDBName?: string; SchemaName?: string; TableName?: string; Name?: string; KeyName?: string; KeyType?: string; RefKeyUID?: string; UID?: string; Position?: number; OID?: number; Tables?: SYS.Tables; }): SYS.KeyColumns;
    add(item: SYS.KeyColumns): SYS.KeyColumns;

    attach(item: SYS.KeyColumns): void;
    attach(item: { VDBName: string; SchemaName: string; TableName: string; Name: string; }): void;
    attachOrGet(item: SYS.KeyColumns): SYS.KeyColumns;
    attachOrGet(item: { VDBName: string; SchemaName: string; TableName: string; Name: string; }): SYS.KeyColumns;

    detach(item: SYS.KeyColumns): void;
    detach(item: { VDBName: string; SchemaName: string; TableName: string; Name: string; }): void;

    remove(item: SYS.KeyColumns): void;
    remove(item: { VDBName: string; SchemaName: string; TableName: string; Name: string; }): void;
    
    elementType: new (initData: { VDBName?: string; SchemaName?: string; TableName?: string; Name?: string; KeyName?: string; KeyType?: string; RefKeyUID?: string; UID?: string; Position?: number; OID?: number; Tables?: SYS.Tables; }) => SYS.KeyColumns;
  }

  class Keys extends $data.Entity {
    constructor ();
    constructor (initData: { VDBName?: string; SchemaName?: string; TableName?: string; Name?: string; Description?: string; NameInSource?: string; Type?: string; IsIndexed?: boolean; RefKeyUID?: string; UID?: string; OID?: number; Tables?: SYS.Tables; });
    VDBName: string;
    SchemaName: string;
    TableName: string;
    Name: string;
    Description: string;
    NameInSource: string;
    Type: string;
    IsIndexed: boolean;
    RefKeyUID: string;
    UID: string;
    OID: number;
    Tables: SYS.Tables;
    
  }

  export interface KeysQueryable extends $data.Queryable {
    filter(predicate:(it: SYS.Keys) => boolean): SYS.KeysQueryable;
    filter(predicate:(it: SYS.Keys) => boolean, thisArg: any): SYS.KeysQueryable;

    map(projection: (it: SYS.Keys) => any): SYS.KeysQueryable;

    length(): $data.IPromise;
    length(handler: (result: number) => void): $data.IPromise;
    length(handler: { success?: (result: number) => void; error?: (result: any) => void; }): $data.IPromise;

    forEach(handler: (it: SYS.Keys) => void ): $data.IPromise;
    
    toArray(): $data.IPromise;
    toArray(handler: (result: SYS.Keys[]) => void): $data.IPromise;
    toArray(handler: { success?: (result: SYS.Keys[]) => void; error?: (result: any) => void; }): $data.IPromise;

    single(predicate: (it: SYS.Keys, params?: any) => boolean, params?: any, handler?: (result: SYS.Keys) => void): $data.IPromise;
    single(predicate: (it: SYS.Keys, params?: any) => boolean, params?: any, handler?: { success?: (result: SYS.Keys[]) => void; error?: (result: any) => void; }): $data.IPromise;

    take(amout: number): SYS.KeysQueryable;
    skip(amout: number): SYS.KeysQueryable;

    order(selector: string): SYS.KeysQueryable;
    orderBy(predicate: (it: SYS.Keys) => any): SYS.KeysQueryable;
    orderByDescending(predicate: (it: SYS.Keys) => any): SYS.KeysQueryable;
    
    first(predicate: (it: SYS.Keys, params?: any) => boolean, params?: any, handler?: (result: SYS.Keys) => void): $data.IPromise;
    first(predicate: (it: SYS.Keys, params?: any) => boolean, params?: any, handler?: { success?: (result: SYS.Keys[]) => void; error?: (result: any) => void; }): $data.IPromise;
    
    include(selector: string): SYS.KeysQueryable;

    removeAll(): $data.IPromise;
    removeAll(handler: (count: number) => void): $data.IPromise;
    removeAll(handler: { success?: (result: number) => void; error?: (result: any) => void; }): $data.IPromise;
  }


  export interface KeysSet extends KeysQueryable {
    add(initData: { VDBName?: string; SchemaName?: string; TableName?: string; Name?: string; Description?: string; NameInSource?: string; Type?: string; IsIndexed?: boolean; RefKeyUID?: string; UID?: string; OID?: number; Tables?: SYS.Tables; }): SYS.Keys;
    add(item: SYS.Keys): SYS.Keys;

    attach(item: SYS.Keys): void;
    attach(item: { VDBName: string; SchemaName: string; TableName: string; Name: string; }): void;
    attachOrGet(item: SYS.Keys): SYS.Keys;
    attachOrGet(item: { VDBName: string; SchemaName: string; TableName: string; Name: string; }): SYS.Keys;

    detach(item: SYS.Keys): void;
    detach(item: { VDBName: string; SchemaName: string; TableName: string; Name: string; }): void;

    remove(item: SYS.Keys): void;
    remove(item: { VDBName: string; SchemaName: string; TableName: string; Name: string; }): void;
    
    elementType: new (initData: { VDBName?: string; SchemaName?: string; TableName?: string; Name?: string; Description?: string; NameInSource?: string; Type?: string; IsIndexed?: boolean; RefKeyUID?: string; UID?: string; OID?: number; Tables?: SYS.Tables; }) => SYS.Keys;
  }

  class ProcedureParams extends $data.Entity {
    constructor ();
    constructor (initData: { VDBName?: string; SchemaName?: string; ProcedureName?: string; Name?: string; DataType?: string; Position?: number; Type?: string; Optional?: boolean; Precision?: number; TypeLength?: number; Scale?: number; Radix?: number; NullType?: string; UID?: string; Description?: string; OID?: number; Procedures?: SYS.Procedures; DataTypes?: SYS.DataTypes; });
    VDBName: string;
    SchemaName: string;
    ProcedureName: string;
    Name: string;
    DataType: string;
    Position: number;
    Type: string;
    Optional: boolean;
    Precision: number;
    TypeLength: number;
    Scale: number;
    Radix: number;
    NullType: string;
    UID: string;
    Description: string;
    OID: number;
    Procedures: SYS.Procedures;
    DataTypes: SYS.DataTypes;
    
  }

  export interface ProcedureParamsQueryable extends $data.Queryable {
    filter(predicate:(it: SYS.ProcedureParams) => boolean): SYS.ProcedureParamsQueryable;
    filter(predicate:(it: SYS.ProcedureParams) => boolean, thisArg: any): SYS.ProcedureParamsQueryable;

    map(projection: (it: SYS.ProcedureParams) => any): SYS.ProcedureParamsQueryable;

    length(): $data.IPromise;
    length(handler: (result: number) => void): $data.IPromise;
    length(handler: { success?: (result: number) => void; error?: (result: any) => void; }): $data.IPromise;

    forEach(handler: (it: SYS.ProcedureParams) => void ): $data.IPromise;
    
    toArray(): $data.IPromise;
    toArray(handler: (result: SYS.ProcedureParams[]) => void): $data.IPromise;
    toArray(handler: { success?: (result: SYS.ProcedureParams[]) => void; error?: (result: any) => void; }): $data.IPromise;

    single(predicate: (it: SYS.ProcedureParams, params?: any) => boolean, params?: any, handler?: (result: SYS.ProcedureParams) => void): $data.IPromise;
    single(predicate: (it: SYS.ProcedureParams, params?: any) => boolean, params?: any, handler?: { success?: (result: SYS.ProcedureParams[]) => void; error?: (result: any) => void; }): $data.IPromise;

    take(amout: number): SYS.ProcedureParamsQueryable;
    skip(amout: number): SYS.ProcedureParamsQueryable;

    order(selector: string): SYS.ProcedureParamsQueryable;
    orderBy(predicate: (it: SYS.ProcedureParams) => any): SYS.ProcedureParamsQueryable;
    orderByDescending(predicate: (it: SYS.ProcedureParams) => any): SYS.ProcedureParamsQueryable;
    
    first(predicate: (it: SYS.ProcedureParams, params?: any) => boolean, params?: any, handler?: (result: SYS.ProcedureParams) => void): $data.IPromise;
    first(predicate: (it: SYS.ProcedureParams, params?: any) => boolean, params?: any, handler?: { success?: (result: SYS.ProcedureParams[]) => void; error?: (result: any) => void; }): $data.IPromise;
    
    include(selector: string): SYS.ProcedureParamsQueryable;

    removeAll(): $data.IPromise;
    removeAll(handler: (count: number) => void): $data.IPromise;
    removeAll(handler: { success?: (result: number) => void; error?: (result: any) => void; }): $data.IPromise;
  }


  export interface ProcedureParamsSet extends ProcedureParamsQueryable {
    add(initData: { VDBName?: string; SchemaName?: string; ProcedureName?: string; Name?: string; DataType?: string; Position?: number; Type?: string; Optional?: boolean; Precision?: number; TypeLength?: number; Scale?: number; Radix?: number; NullType?: string; UID?: string; Description?: string; OID?: number; Procedures?: SYS.Procedures; DataTypes?: SYS.DataTypes; }): SYS.ProcedureParams;
    add(item: SYS.ProcedureParams): SYS.ProcedureParams;

    attach(item: SYS.ProcedureParams): void;
    attach(item: { VDBName: string; SchemaName: string; ProcedureName: string; Name: string; }): void;
    attachOrGet(item: SYS.ProcedureParams): SYS.ProcedureParams;
    attachOrGet(item: { VDBName: string; SchemaName: string; ProcedureName: string; Name: string; }): SYS.ProcedureParams;

    detach(item: SYS.ProcedureParams): void;
    detach(item: { VDBName: string; SchemaName: string; ProcedureName: string; Name: string; }): void;

    remove(item: SYS.ProcedureParams): void;
    remove(item: { VDBName: string; SchemaName: string; ProcedureName: string; Name: string; }): void;
    
    elementType: new (initData: { VDBName?: string; SchemaName?: string; ProcedureName?: string; Name?: string; DataType?: string; Position?: number; Type?: string; Optional?: boolean; Precision?: number; TypeLength?: number; Scale?: number; Radix?: number; NullType?: string; UID?: string; Description?: string; OID?: number; Procedures?: SYS.Procedures; DataTypes?: SYS.DataTypes; }) => SYS.ProcedureParams;
  }

  class Procedures extends $data.Entity {
    constructor ();
    constructor (initData: { VDBName?: string; SchemaName?: string; Name?: string; NameInSource?: string; ReturnsResults?: boolean; UID?: string; Description?: string; OID?: number; ProcedureParams?: SYS.ProcedureParams[]; Schemas?: SYS.Schemas; });
    VDBName: string;
    SchemaName: string;
    Name: string;
    NameInSource: string;
    ReturnsResults: boolean;
    UID: string;
    Description: string;
    OID: number;
    ProcedureParams: SYS.ProcedureParams[];
    Schemas: SYS.Schemas;
    
  }

  export interface ProceduresQueryable extends $data.Queryable {
    filter(predicate:(it: SYS.Procedures) => boolean): SYS.ProceduresQueryable;
    filter(predicate:(it: SYS.Procedures) => boolean, thisArg: any): SYS.ProceduresQueryable;

    map(projection: (it: SYS.Procedures) => any): SYS.ProceduresQueryable;

    length(): $data.IPromise;
    length(handler: (result: number) => void): $data.IPromise;
    length(handler: { success?: (result: number) => void; error?: (result: any) => void; }): $data.IPromise;

    forEach(handler: (it: SYS.Procedures) => void ): $data.IPromise;
    
    toArray(): $data.IPromise;
    toArray(handler: (result: SYS.Procedures[]) => void): $data.IPromise;
    toArray(handler: { success?: (result: SYS.Procedures[]) => void; error?: (result: any) => void; }): $data.IPromise;

    single(predicate: (it: SYS.Procedures, params?: any) => boolean, params?: any, handler?: (result: SYS.Procedures) => void): $data.IPromise;
    single(predicate: (it: SYS.Procedures, params?: any) => boolean, params?: any, handler?: { success?: (result: SYS.Procedures[]) => void; error?: (result: any) => void; }): $data.IPromise;

    take(amout: number): SYS.ProceduresQueryable;
    skip(amout: number): SYS.ProceduresQueryable;

    order(selector: string): SYS.ProceduresQueryable;
    orderBy(predicate: (it: SYS.Procedures) => any): SYS.ProceduresQueryable;
    orderByDescending(predicate: (it: SYS.Procedures) => any): SYS.ProceduresQueryable;
    
    first(predicate: (it: SYS.Procedures, params?: any) => boolean, params?: any, handler?: (result: SYS.Procedures) => void): $data.IPromise;
    first(predicate: (it: SYS.Procedures, params?: any) => boolean, params?: any, handler?: { success?: (result: SYS.Procedures[]) => void; error?: (result: any) => void; }): $data.IPromise;
    
    include(selector: string): SYS.ProceduresQueryable;

    removeAll(): $data.IPromise;
    removeAll(handler: (count: number) => void): $data.IPromise;
    removeAll(handler: { success?: (result: number) => void; error?: (result: any) => void; }): $data.IPromise;
  }


  export interface ProceduresSet extends ProceduresQueryable {
    add(initData: { VDBName?: string; SchemaName?: string; Name?: string; NameInSource?: string; ReturnsResults?: boolean; UID?: string; Description?: string; OID?: number; ProcedureParams?: SYS.ProcedureParams[]; Schemas?: SYS.Schemas; }): SYS.Procedures;
    add(item: SYS.Procedures): SYS.Procedures;

    attach(item: SYS.Procedures): void;
    attach(item: { VDBName: string; SchemaName: string; Name: string; }): void;
    attachOrGet(item: SYS.Procedures): SYS.Procedures;
    attachOrGet(item: { VDBName: string; SchemaName: string; Name: string; }): SYS.Procedures;

    detach(item: SYS.Procedures): void;
    detach(item: { VDBName: string; SchemaName: string; Name: string; }): void;

    remove(item: SYS.Procedures): void;
    remove(item: { VDBName: string; SchemaName: string; Name: string; }): void;
    
    elementType: new (initData: { VDBName?: string; SchemaName?: string; Name?: string; NameInSource?: string; ReturnsResults?: boolean; UID?: string; Description?: string; OID?: number; ProcedureParams?: SYS.ProcedureParams[]; Schemas?: SYS.Schemas; }) => SYS.Procedures;
  }

  class Properties extends $data.Entity {
    constructor ();
    constructor (initData: { Name?: string; Value?: string; UID?: string; OID?: number; ClobValue?: $data.Blob; });
    Name: string;
    Value: string;
    UID: string;
    OID: number;
    ClobValue: $data.Blob;
    
  }

  export interface PropertiesQueryable extends $data.Queryable {
    filter(predicate:(it: SYS.Properties) => boolean): SYS.PropertiesQueryable;
    filter(predicate:(it: SYS.Properties) => boolean, thisArg: any): SYS.PropertiesQueryable;

    map(projection: (it: SYS.Properties) => any): SYS.PropertiesQueryable;

    length(): $data.IPromise;
    length(handler: (result: number) => void): $data.IPromise;
    length(handler: { success?: (result: number) => void; error?: (result: any) => void; }): $data.IPromise;

    forEach(handler: (it: SYS.Properties) => void ): $data.IPromise;
    
    toArray(): $data.IPromise;
    toArray(handler: (result: SYS.Properties[]) => void): $data.IPromise;
    toArray(handler: { success?: (result: SYS.Properties[]) => void; error?: (result: any) => void; }): $data.IPromise;

    single(predicate: (it: SYS.Properties, params?: any) => boolean, params?: any, handler?: (result: SYS.Properties) => void): $data.IPromise;
    single(predicate: (it: SYS.Properties, params?: any) => boolean, params?: any, handler?: { success?: (result: SYS.Properties[]) => void; error?: (result: any) => void; }): $data.IPromise;

    take(amout: number): SYS.PropertiesQueryable;
    skip(amout: number): SYS.PropertiesQueryable;

    order(selector: string): SYS.PropertiesQueryable;
    orderBy(predicate: (it: SYS.Properties) => any): SYS.PropertiesQueryable;
    orderByDescending(predicate: (it: SYS.Properties) => any): SYS.PropertiesQueryable;
    
    first(predicate: (it: SYS.Properties, params?: any) => boolean, params?: any, handler?: (result: SYS.Properties) => void): $data.IPromise;
    first(predicate: (it: SYS.Properties, params?: any) => boolean, params?: any, handler?: { success?: (result: SYS.Properties[]) => void; error?: (result: any) => void; }): $data.IPromise;
    
    include(selector: string): SYS.PropertiesQueryable;

    removeAll(): $data.IPromise;
    removeAll(handler: (count: number) => void): $data.IPromise;
    removeAll(handler: { success?: (result: number) => void; error?: (result: any) => void; }): $data.IPromise;
  }


  export interface PropertiesSet extends PropertiesQueryable {
    add(initData: { Name?: string; Value?: string; UID?: string; OID?: number; ClobValue?: $data.Blob; }): SYS.Properties;
    add(item: SYS.Properties): SYS.Properties;

    attach(item: SYS.Properties): void;
    attach(item: { Name: string; UID: string; }): void;
    attachOrGet(item: SYS.Properties): SYS.Properties;
    attachOrGet(item: { Name: string; UID: string; }): SYS.Properties;

    detach(item: SYS.Properties): void;
    detach(item: { Name: string; UID: string; }): void;

    remove(item: SYS.Properties): void;
    remove(item: { Name: string; UID: string; }): void;
    
    elementType: new (initData: { Name?: string; Value?: string; UID?: string; OID?: number; ClobValue?: $data.Blob; }) => SYS.Properties;
  }

  class Schemas extends $data.Entity {
    constructor ();
    constructor (initData: { VDBName?: string; Name?: string; IsPhysical?: boolean; UID?: string; Description?: string; PrimaryMetamodelURI?: string; OID?: number; Procedures?: SYS.Procedures[]; Tables?: SYS.Tables[]; });
    VDBName: string;
    Name: string;
    IsPhysical: boolean;
    UID: string;
    Description: string;
    PrimaryMetamodelURI: string;
    OID: number;
    Procedures: SYS.Procedures[];
    Tables: SYS.Tables[];
    
  }

  export interface SchemasQueryable extends $data.Queryable {
    filter(predicate:(it: SYS.Schemas) => boolean): SYS.SchemasQueryable;
    filter(predicate:(it: SYS.Schemas) => boolean, thisArg: any): SYS.SchemasQueryable;

    map(projection: (it: SYS.Schemas) => any): SYS.SchemasQueryable;

    length(): $data.IPromise;
    length(handler: (result: number) => void): $data.IPromise;
    length(handler: { success?: (result: number) => void; error?: (result: any) => void; }): $data.IPromise;

    forEach(handler: (it: SYS.Schemas) => void ): $data.IPromise;
    
    toArray(): $data.IPromise;
    toArray(handler: (result: SYS.Schemas[]) => void): $data.IPromise;
    toArray(handler: { success?: (result: SYS.Schemas[]) => void; error?: (result: any) => void; }): $data.IPromise;

    single(predicate: (it: SYS.Schemas, params?: any) => boolean, params?: any, handler?: (result: SYS.Schemas) => void): $data.IPromise;
    single(predicate: (it: SYS.Schemas, params?: any) => boolean, params?: any, handler?: { success?: (result: SYS.Schemas[]) => void; error?: (result: any) => void; }): $data.IPromise;

    take(amout: number): SYS.SchemasQueryable;
    skip(amout: number): SYS.SchemasQueryable;

    order(selector: string): SYS.SchemasQueryable;
    orderBy(predicate: (it: SYS.Schemas) => any): SYS.SchemasQueryable;
    orderByDescending(predicate: (it: SYS.Schemas) => any): SYS.SchemasQueryable;
    
    first(predicate: (it: SYS.Schemas, params?: any) => boolean, params?: any, handler?: (result: SYS.Schemas) => void): $data.IPromise;
    first(predicate: (it: SYS.Schemas, params?: any) => boolean, params?: any, handler?: { success?: (result: SYS.Schemas[]) => void; error?: (result: any) => void; }): $data.IPromise;
    
    include(selector: string): SYS.SchemasQueryable;

    removeAll(): $data.IPromise;
    removeAll(handler: (count: number) => void): $data.IPromise;
    removeAll(handler: { success?: (result: number) => void; error?: (result: any) => void; }): $data.IPromise;
  }


  export interface SchemasSet extends SchemasQueryable {
    add(initData: { VDBName?: string; Name?: string; IsPhysical?: boolean; UID?: string; Description?: string; PrimaryMetamodelURI?: string; OID?: number; Procedures?: SYS.Procedures[]; Tables?: SYS.Tables[]; }): SYS.Schemas;
    add(item: SYS.Schemas): SYS.Schemas;

    attach(item: SYS.Schemas): void;
    attach(item: { VDBName: string; Name: string; }): void;
    attachOrGet(item: SYS.Schemas): SYS.Schemas;
    attachOrGet(item: { VDBName: string; Name: string; }): SYS.Schemas;

    detach(item: SYS.Schemas): void;
    detach(item: { VDBName: string; Name: string; }): void;

    remove(item: SYS.Schemas): void;
    remove(item: { VDBName: string; Name: string; }): void;
    
    elementType: new (initData: { VDBName?: string; Name?: string; IsPhysical?: boolean; UID?: string; Description?: string; PrimaryMetamodelURI?: string; OID?: number; Procedures?: SYS.Procedures[]; Tables?: SYS.Tables[]; }) => SYS.Schemas;
  }

  class Tables extends $data.Entity {
    constructor ();
    constructor (initData: { VDBName?: string; SchemaName?: string; Name?: string; Type?: string; NameInSource?: string; IsPhysical?: boolean; SupportsUpdates?: boolean; UID?: string; Cardinality?: number; Description?: string; IsSystem?: boolean; IsMaterialized?: boolean; OID?: number; Columns?: SYS.Columns[]; KeyColumns?: SYS.KeyColumns[]; Keys?: SYS.Keys[]; Schemas?: SYS.Schemas; });
    VDBName: string;
    SchemaName: string;
    Name: string;
    Type: string;
    NameInSource: string;
    IsPhysical: boolean;
    SupportsUpdates: boolean;
    UID: string;
    Cardinality: number;
    Description: string;
    IsSystem: boolean;
    IsMaterialized: boolean;
    OID: number;
    Columns: SYS.Columns[];
    KeyColumns: SYS.KeyColumns[];
    Keys: SYS.Keys[];
    Schemas: SYS.Schemas;
    
  }

  export interface TablesQueryable extends $data.Queryable {
    filter(predicate:(it: SYS.Tables) => boolean): SYS.TablesQueryable;
    filter(predicate:(it: SYS.Tables) => boolean, thisArg: any): SYS.TablesQueryable;

    map(projection: (it: SYS.Tables) => any): SYS.TablesQueryable;

    length(): $data.IPromise;
    length(handler: (result: number) => void): $data.IPromise;
    length(handler: { success?: (result: number) => void; error?: (result: any) => void; }): $data.IPromise;

    forEach(handler: (it: SYS.Tables) => void ): $data.IPromise;
    
    toArray(): $data.IPromise;
    toArray(handler: (result: SYS.Tables[]) => void): $data.IPromise;
    toArray(handler: { success?: (result: SYS.Tables[]) => void; error?: (result: any) => void; }): $data.IPromise;

    single(predicate: (it: SYS.Tables, params?: any) => boolean, params?: any, handler?: (result: SYS.Tables) => void): $data.IPromise;
    single(predicate: (it: SYS.Tables, params?: any) => boolean, params?: any, handler?: { success?: (result: SYS.Tables[]) => void; error?: (result: any) => void; }): $data.IPromise;

    take(amout: number): SYS.TablesQueryable;
    skip(amout: number): SYS.TablesQueryable;

    order(selector: string): SYS.TablesQueryable;
    orderBy(predicate: (it: SYS.Tables) => any): SYS.TablesQueryable;
    orderByDescending(predicate: (it: SYS.Tables) => any): SYS.TablesQueryable;
    
    first(predicate: (it: SYS.Tables, params?: any) => boolean, params?: any, handler?: (result: SYS.Tables) => void): $data.IPromise;
    first(predicate: (it: SYS.Tables, params?: any) => boolean, params?: any, handler?: { success?: (result: SYS.Tables[]) => void; error?: (result: any) => void; }): $data.IPromise;
    
    include(selector: string): SYS.TablesQueryable;

    removeAll(): $data.IPromise;
    removeAll(handler: (count: number) => void): $data.IPromise;
    removeAll(handler: { success?: (result: number) => void; error?: (result: any) => void; }): $data.IPromise;
  }


  export interface TablesSet extends TablesQueryable {
    add(initData: { VDBName?: string; SchemaName?: string; Name?: string; Type?: string; NameInSource?: string; IsPhysical?: boolean; SupportsUpdates?: boolean; UID?: string; Cardinality?: number; Description?: string; IsSystem?: boolean; IsMaterialized?: boolean; OID?: number; Columns?: SYS.Columns[]; KeyColumns?: SYS.KeyColumns[]; Keys?: SYS.Keys[]; Schemas?: SYS.Schemas; }): SYS.Tables;
    add(item: SYS.Tables): SYS.Tables;

    attach(item: SYS.Tables): void;
    attach(item: { VDBName: string; SchemaName: string; Name: string; }): void;
    attachOrGet(item: SYS.Tables): SYS.Tables;
    attachOrGet(item: { VDBName: string; SchemaName: string; Name: string; }): SYS.Tables;

    detach(item: SYS.Tables): void;
    detach(item: { VDBName: string; SchemaName: string; Name: string; }): void;

    remove(item: SYS.Tables): void;
    remove(item: { VDBName: string; SchemaName: string; Name: string; }): void;
    
    elementType: new (initData: { VDBName?: string; SchemaName?: string; Name?: string; Type?: string; NameInSource?: string; IsPhysical?: boolean; SupportsUpdates?: boolean; UID?: string; Cardinality?: number; Description?: string; IsSystem?: boolean; IsMaterialized?: boolean; OID?: number; Columns?: SYS.Columns[]; KeyColumns?: SYS.KeyColumns[]; Keys?: SYS.Keys[]; Schemas?: SYS.Schemas; }) => SYS.Tables;
  }

  class VirtualDatabases extends $data.Entity {
    constructor ();
    constructor (initData: { Name?: string; Version?: string; });
    Name: string;
    Version: string;
    
  }

  export interface VirtualDatabasesQueryable extends $data.Queryable {
    filter(predicate:(it: SYS.VirtualDatabases) => boolean): SYS.VirtualDatabasesQueryable;
    filter(predicate:(it: SYS.VirtualDatabases) => boolean, thisArg: any): SYS.VirtualDatabasesQueryable;

    map(projection: (it: SYS.VirtualDatabases) => any): SYS.VirtualDatabasesQueryable;

    length(): $data.IPromise;
    length(handler: (result: number) => void): $data.IPromise;
    length(handler: { success?: (result: number) => void; error?: (result: any) => void; }): $data.IPromise;

    forEach(handler: (it: SYS.VirtualDatabases) => void ): $data.IPromise;
    
    toArray(): $data.IPromise;
    toArray(handler: (result: SYS.VirtualDatabases[]) => void): $data.IPromise;
    toArray(handler: { success?: (result: SYS.VirtualDatabases[]) => void; error?: (result: any) => void; }): $data.IPromise;

    single(predicate: (it: SYS.VirtualDatabases, params?: any) => boolean, params?: any, handler?: (result: SYS.VirtualDatabases) => void): $data.IPromise;
    single(predicate: (it: SYS.VirtualDatabases, params?: any) => boolean, params?: any, handler?: { success?: (result: SYS.VirtualDatabases[]) => void; error?: (result: any) => void; }): $data.IPromise;

    take(amout: number): SYS.VirtualDatabasesQueryable;
    skip(amout: number): SYS.VirtualDatabasesQueryable;

    order(selector: string): SYS.VirtualDatabasesQueryable;
    orderBy(predicate: (it: SYS.VirtualDatabases) => any): SYS.VirtualDatabasesQueryable;
    orderByDescending(predicate: (it: SYS.VirtualDatabases) => any): SYS.VirtualDatabasesQueryable;
    
    first(predicate: (it: SYS.VirtualDatabases, params?: any) => boolean, params?: any, handler?: (result: SYS.VirtualDatabases) => void): $data.IPromise;
    first(predicate: (it: SYS.VirtualDatabases, params?: any) => boolean, params?: any, handler?: { success?: (result: SYS.VirtualDatabases[]) => void; error?: (result: any) => void; }): $data.IPromise;
    
    include(selector: string): SYS.VirtualDatabasesQueryable;

    removeAll(): $data.IPromise;
    removeAll(handler: (count: number) => void): $data.IPromise;
    removeAll(handler: { success?: (result: number) => void; error?: (result: any) => void; }): $data.IPromise;
  }


  export interface VirtualDatabasesSet extends VirtualDatabasesQueryable {
    add(initData: { Name?: string; Version?: string; }): SYS.VirtualDatabases;
    add(item: SYS.VirtualDatabases): SYS.VirtualDatabases;

    attach(item: SYS.VirtualDatabases): void;
    attach(item: { Name: string; Version: string; }): void;
    attachOrGet(item: SYS.VirtualDatabases): SYS.VirtualDatabases;
    attachOrGet(item: { Name: string; Version: string; }): SYS.VirtualDatabases;

    detach(item: SYS.VirtualDatabases): void;
    detach(item: { Name: string; Version: string; }): void;

    remove(item: SYS.VirtualDatabases): void;
    remove(item: { Name: string; Version: string; }): void;
    
    elementType: new (initData: { Name?: string; Version?: string; }) => SYS.VirtualDatabases;
  }

  class getXMLSchemas_RSParam extends $data.Entity {
    constructor ();
    constructor (initData: { schema?: $data.Blob; });
    schema: $data.Blob;
    
  }

  export interface getXMLSchemas_RSParamQueryable extends $data.Queryable {
    filter(predicate:(it: SYS.getXMLSchemas_RSParam) => boolean): SYS.getXMLSchemas_RSParamQueryable;
    filter(predicate:(it: SYS.getXMLSchemas_RSParam) => boolean, thisArg: any): SYS.getXMLSchemas_RSParamQueryable;

    map(projection: (it: SYS.getXMLSchemas_RSParam) => any): SYS.getXMLSchemas_RSParamQueryable;

    length(): $data.IPromise;
    length(handler: (result: number) => void): $data.IPromise;
    length(handler: { success?: (result: number) => void; error?: (result: any) => void; }): $data.IPromise;

    forEach(handler: (it: SYS.getXMLSchemas_RSParam) => void ): $data.IPromise;
    
    toArray(): $data.IPromise;
    toArray(handler: (result: SYS.getXMLSchemas_RSParam[]) => void): $data.IPromise;
    toArray(handler: { success?: (result: SYS.getXMLSchemas_RSParam[]) => void; error?: (result: any) => void; }): $data.IPromise;

    single(predicate: (it: SYS.getXMLSchemas_RSParam, params?: any) => boolean, params?: any, handler?: (result: SYS.getXMLSchemas_RSParam) => void): $data.IPromise;
    single(predicate: (it: SYS.getXMLSchemas_RSParam, params?: any) => boolean, params?: any, handler?: { success?: (result: SYS.getXMLSchemas_RSParam[]) => void; error?: (result: any) => void; }): $data.IPromise;

    take(amout: number): SYS.getXMLSchemas_RSParamQueryable;
    skip(amout: number): SYS.getXMLSchemas_RSParamQueryable;

    order(selector: string): SYS.getXMLSchemas_RSParamQueryable;
    orderBy(predicate: (it: SYS.getXMLSchemas_RSParam) => any): SYS.getXMLSchemas_RSParamQueryable;
    orderByDescending(predicate: (it: SYS.getXMLSchemas_RSParam) => any): SYS.getXMLSchemas_RSParamQueryable;
    
    first(predicate: (it: SYS.getXMLSchemas_RSParam, params?: any) => boolean, params?: any, handler?: (result: SYS.getXMLSchemas_RSParam) => void): $data.IPromise;
    first(predicate: (it: SYS.getXMLSchemas_RSParam, params?: any) => boolean, params?: any, handler?: { success?: (result: SYS.getXMLSchemas_RSParam[]) => void; error?: (result: any) => void; }): $data.IPromise;
    
    include(selector: string): SYS.getXMLSchemas_RSParamQueryable;

    removeAll(): $data.IPromise;
    removeAll(handler: (count: number) => void): $data.IPromise;
    removeAll(handler: { success?: (result: number) => void; error?: (result: any) => void; }): $data.IPromise;
  }

  export class SYS extends $data.EntityContext {
    onReady(handler: (context: SYS) => void): $data.IPromise;
    Columns: SYS.ColumnsSet;
    DataTypes: SYS.DataTypesSet;
    KeyColumns: SYS.KeyColumnsSet;
    Keys: SYS.KeysSet;
    ProcedureParams: SYS.ProcedureParamsSet;
    Procedures: SYS.ProceduresSet;
    Properties: SYS.PropertiesSet;
    Schemas: SYS.SchemasSet;
    Tables: SYS.TablesSet;
    VirtualDatabases: SYS.VirtualDatabasesSet;
    getXMLSchemas: { (document: string): SYS.getXMLSchemas_RSParamQueryable; (document: string, handler: (result: SYS.getXMLSchemas_RSParam[]) => void): $data.IPromise; };
    
  }
}

declare module SYSADMIN {
  class MatViews extends $data.Entity {
    constructor ();
    constructor (initData: { VDBName?: string; SchemaName?: string; Name?: string; TargetSchemaName?: string; TargetName?: string; Valid?: boolean; LoadState?: string; Updated?: Date; Cardinality?: number; });
    VDBName: string;
    SchemaName: string;
    Name: string;
    TargetSchemaName: string;
    TargetName: string;
    Valid: boolean;
    LoadState: string;
    Updated: Date;
    Cardinality: number;
    
  }

  export interface MatViewsQueryable extends $data.Queryable {
    filter(predicate:(it: SYSADMIN.MatViews) => boolean): SYSADMIN.MatViewsQueryable;
    filter(predicate:(it: SYSADMIN.MatViews) => boolean, thisArg: any): SYSADMIN.MatViewsQueryable;

    map(projection: (it: SYSADMIN.MatViews) => any): SYSADMIN.MatViewsQueryable;

    length(): $data.IPromise;
    length(handler: (result: number) => void): $data.IPromise;
    length(handler: { success?: (result: number) => void; error?: (result: any) => void; }): $data.IPromise;

    forEach(handler: (it: SYSADMIN.MatViews) => void ): $data.IPromise;
    
    toArray(): $data.IPromise;
    toArray(handler: (result: SYSADMIN.MatViews[]) => void): $data.IPromise;
    toArray(handler: { success?: (result: SYSADMIN.MatViews[]) => void; error?: (result: any) => void; }): $data.IPromise;

    single(predicate: (it: SYSADMIN.MatViews, params?: any) => boolean, params?: any, handler?: (result: SYSADMIN.MatViews) => void): $data.IPromise;
    single(predicate: (it: SYSADMIN.MatViews, params?: any) => boolean, params?: any, handler?: { success?: (result: SYSADMIN.MatViews[]) => void; error?: (result: any) => void; }): $data.IPromise;

    take(amout: number): SYSADMIN.MatViewsQueryable;
    skip(amout: number): SYSADMIN.MatViewsQueryable;

    order(selector: string): SYSADMIN.MatViewsQueryable;
    orderBy(predicate: (it: SYSADMIN.MatViews) => any): SYSADMIN.MatViewsQueryable;
    orderByDescending(predicate: (it: SYSADMIN.MatViews) => any): SYSADMIN.MatViewsQueryable;
    
    first(predicate: (it: SYSADMIN.MatViews, params?: any) => boolean, params?: any, handler?: (result: SYSADMIN.MatViews) => void): $data.IPromise;
    first(predicate: (it: SYSADMIN.MatViews, params?: any) => boolean, params?: any, handler?: { success?: (result: SYSADMIN.MatViews[]) => void; error?: (result: any) => void; }): $data.IPromise;
    
    include(selector: string): SYSADMIN.MatViewsQueryable;

    removeAll(): $data.IPromise;
    removeAll(handler: (count: number) => void): $data.IPromise;
    removeAll(handler: { success?: (result: number) => void; error?: (result: any) => void; }): $data.IPromise;
  }


  export interface MatViewsSet extends MatViewsQueryable {
    add(initData: { VDBName?: string; SchemaName?: string; Name?: string; TargetSchemaName?: string; TargetName?: string; Valid?: boolean; LoadState?: string; Updated?: Date; Cardinality?: number; }): SYSADMIN.MatViews;
    add(item: SYSADMIN.MatViews): SYSADMIN.MatViews;

    attach(item: SYSADMIN.MatViews): void;
    attach(item: { VDBName: string; SchemaName: string; Name: string; }): void;
    attachOrGet(item: SYSADMIN.MatViews): SYSADMIN.MatViews;
    attachOrGet(item: { VDBName: string; SchemaName: string; Name: string; }): SYSADMIN.MatViews;

    detach(item: SYSADMIN.MatViews): void;
    detach(item: { VDBName: string; SchemaName: string; Name: string; }): void;

    remove(item: SYSADMIN.MatViews): void;
    remove(item: { VDBName: string; SchemaName: string; Name: string; }): void;
    
    elementType: new (initData: { VDBName?: string; SchemaName?: string; Name?: string; TargetSchemaName?: string; TargetName?: string; Valid?: boolean; LoadState?: string; Updated?: Date; Cardinality?: number; }) => SYSADMIN.MatViews;
  }

  class Triggers extends $data.Entity {
    constructor ();
    constructor (initData: { VDBName?: string; SchemaName?: string; TableName?: string; Name?: string; TriggerType?: string; TriggerEvent?: string; Status?: string; Body?: $data.Blob; TableUID?: string; });
    VDBName: string;
    SchemaName: string;
    TableName: string;
    Name: string;
    TriggerType: string;
    TriggerEvent: string;
    Status: string;
    Body: $data.Blob;
    TableUID: string;
    
  }

  export interface TriggersQueryable extends $data.Queryable {
    filter(predicate:(it: SYSADMIN.Triggers) => boolean): SYSADMIN.TriggersQueryable;
    filter(predicate:(it: SYSADMIN.Triggers) => boolean, thisArg: any): SYSADMIN.TriggersQueryable;

    map(projection: (it: SYSADMIN.Triggers) => any): SYSADMIN.TriggersQueryable;

    length(): $data.IPromise;
    length(handler: (result: number) => void): $data.IPromise;
    length(handler: { success?: (result: number) => void; error?: (result: any) => void; }): $data.IPromise;

    forEach(handler: (it: SYSADMIN.Triggers) => void ): $data.IPromise;
    
    toArray(): $data.IPromise;
    toArray(handler: (result: SYSADMIN.Triggers[]) => void): $data.IPromise;
    toArray(handler: { success?: (result: SYSADMIN.Triggers[]) => void; error?: (result: any) => void; }): $data.IPromise;

    single(predicate: (it: SYSADMIN.Triggers, params?: any) => boolean, params?: any, handler?: (result: SYSADMIN.Triggers) => void): $data.IPromise;
    single(predicate: (it: SYSADMIN.Triggers, params?: any) => boolean, params?: any, handler?: { success?: (result: SYSADMIN.Triggers[]) => void; error?: (result: any) => void; }): $data.IPromise;

    take(amout: number): SYSADMIN.TriggersQueryable;
    skip(amout: number): SYSADMIN.TriggersQueryable;

    order(selector: string): SYSADMIN.TriggersQueryable;
    orderBy(predicate: (it: SYSADMIN.Triggers) => any): SYSADMIN.TriggersQueryable;
    orderByDescending(predicate: (it: SYSADMIN.Triggers) => any): SYSADMIN.TriggersQueryable;
    
    first(predicate: (it: SYSADMIN.Triggers, params?: any) => boolean, params?: any, handler?: (result: SYSADMIN.Triggers) => void): $data.IPromise;
    first(predicate: (it: SYSADMIN.Triggers, params?: any) => boolean, params?: any, handler?: { success?: (result: SYSADMIN.Triggers[]) => void; error?: (result: any) => void; }): $data.IPromise;
    
    include(selector: string): SYSADMIN.TriggersQueryable;

    removeAll(): $data.IPromise;
    removeAll(handler: (count: number) => void): $data.IPromise;
    removeAll(handler: { success?: (result: number) => void; error?: (result: any) => void; }): $data.IPromise;
  }


  export interface TriggersSet extends TriggersQueryable {
    add(initData: { VDBName?: string; SchemaName?: string; TableName?: string; Name?: string; TriggerType?: string; TriggerEvent?: string; Status?: string; Body?: $data.Blob; TableUID?: string; }): SYSADMIN.Triggers;
    add(item: SYSADMIN.Triggers): SYSADMIN.Triggers;

    attach(item: SYSADMIN.Triggers): void;
    attach(item: { VDBName: string; SchemaName: string; TableName: string; Name: string; }): void;
    attachOrGet(item: SYSADMIN.Triggers): SYSADMIN.Triggers;
    attachOrGet(item: { VDBName: string; SchemaName: string; TableName: string; Name: string; }): SYSADMIN.Triggers;

    detach(item: SYSADMIN.Triggers): void;
    detach(item: { VDBName: string; SchemaName: string; TableName: string; Name: string; }): void;

    remove(item: SYSADMIN.Triggers): void;
    remove(item: { VDBName: string; SchemaName: string; TableName: string; Name: string; }): void;
    
    elementType: new (initData: { VDBName?: string; SchemaName?: string; TableName?: string; Name?: string; TriggerType?: string; TriggerEvent?: string; Status?: string; Body?: $data.Blob; TableUID?: string; }) => SYSADMIN.Triggers;
  }

  class VDBResources extends $data.Entity {
    constructor ();
    constructor (initData: { resourcePath?: string; contents?: $data.Blob; });
    resourcePath: string;
    contents: $data.Blob;
    
  }

  export interface VDBResourcesQueryable extends $data.Queryable {
    filter(predicate:(it: SYSADMIN.VDBResources) => boolean): SYSADMIN.VDBResourcesQueryable;
    filter(predicate:(it: SYSADMIN.VDBResources) => boolean, thisArg: any): SYSADMIN.VDBResourcesQueryable;

    map(projection: (it: SYSADMIN.VDBResources) => any): SYSADMIN.VDBResourcesQueryable;

    length(): $data.IPromise;
    length(handler: (result: number) => void): $data.IPromise;
    length(handler: { success?: (result: number) => void; error?: (result: any) => void; }): $data.IPromise;

    forEach(handler: (it: SYSADMIN.VDBResources) => void ): $data.IPromise;
    
    toArray(): $data.IPromise;
    toArray(handler: (result: SYSADMIN.VDBResources[]) => void): $data.IPromise;
    toArray(handler: { success?: (result: SYSADMIN.VDBResources[]) => void; error?: (result: any) => void; }): $data.IPromise;

    single(predicate: (it: SYSADMIN.VDBResources, params?: any) => boolean, params?: any, handler?: (result: SYSADMIN.VDBResources) => void): $data.IPromise;
    single(predicate: (it: SYSADMIN.VDBResources, params?: any) => boolean, params?: any, handler?: { success?: (result: SYSADMIN.VDBResources[]) => void; error?: (result: any) => void; }): $data.IPromise;

    take(amout: number): SYSADMIN.VDBResourcesQueryable;
    skip(amout: number): SYSADMIN.VDBResourcesQueryable;

    order(selector: string): SYSADMIN.VDBResourcesQueryable;
    orderBy(predicate: (it: SYSADMIN.VDBResources) => any): SYSADMIN.VDBResourcesQueryable;
    orderByDescending(predicate: (it: SYSADMIN.VDBResources) => any): SYSADMIN.VDBResourcesQueryable;
    
    first(predicate: (it: SYSADMIN.VDBResources, params?: any) => boolean, params?: any, handler?: (result: SYSADMIN.VDBResources) => void): $data.IPromise;
    first(predicate: (it: SYSADMIN.VDBResources, params?: any) => boolean, params?: any, handler?: { success?: (result: SYSADMIN.VDBResources[]) => void; error?: (result: any) => void; }): $data.IPromise;
    
    include(selector: string): SYSADMIN.VDBResourcesQueryable;

    removeAll(): $data.IPromise;
    removeAll(handler: (count: number) => void): $data.IPromise;
    removeAll(handler: { success?: (result: number) => void; error?: (result: any) => void; }): $data.IPromise;
  }


  export interface VDBResourcesSet extends VDBResourcesQueryable {
    add(initData: { resourcePath?: string; contents?: $data.Blob; }): SYSADMIN.VDBResources;
    add(item: SYSADMIN.VDBResources): SYSADMIN.VDBResources;

    attach(item: SYSADMIN.VDBResources): void;
    attach(item: { resourcePath: string; }): void;
    attachOrGet(item: SYSADMIN.VDBResources): SYSADMIN.VDBResources;
    attachOrGet(item: { resourcePath: string; }): SYSADMIN.VDBResources;

    detach(item: SYSADMIN.VDBResources): void;
    detach(item: { resourcePath: string; }): void;

    remove(item: SYSADMIN.VDBResources): void;
    remove(item: { resourcePath: string; }): void;
    
    elementType: new (initData: { resourcePath?: string; contents?: $data.Blob; }) => SYSADMIN.VDBResources;
  }

  class matViewStatus_RSParam extends $data.Entity {
    constructor ();
    constructor (initData: { TargetSchemaName?: string; TargetName?: string; Valid?: boolean; LoadState?: string; Updated?: Date; Cardinality?: number; LoadNumber?: number; OnErrorAction?: string; });
    TargetSchemaName: string;
    TargetName: string;
    Valid: boolean;
    LoadState: string;
    Updated: Date;
    Cardinality: number;
    LoadNumber: number;
    OnErrorAction: string;
    
  }

  export interface matViewStatus_RSParamQueryable extends $data.Queryable {
    filter(predicate:(it: SYSADMIN.matViewStatus_RSParam) => boolean): SYSADMIN.matViewStatus_RSParamQueryable;
    filter(predicate:(it: SYSADMIN.matViewStatus_RSParam) => boolean, thisArg: any): SYSADMIN.matViewStatus_RSParamQueryable;

    map(projection: (it: SYSADMIN.matViewStatus_RSParam) => any): SYSADMIN.matViewStatus_RSParamQueryable;

    length(): $data.IPromise;
    length(handler: (result: number) => void): $data.IPromise;
    length(handler: { success?: (result: number) => void; error?: (result: any) => void; }): $data.IPromise;

    forEach(handler: (it: SYSADMIN.matViewStatus_RSParam) => void ): $data.IPromise;
    
    toArray(): $data.IPromise;
    toArray(handler: (result: SYSADMIN.matViewStatus_RSParam[]) => void): $data.IPromise;
    toArray(handler: { success?: (result: SYSADMIN.matViewStatus_RSParam[]) => void; error?: (result: any) => void; }): $data.IPromise;

    single(predicate: (it: SYSADMIN.matViewStatus_RSParam, params?: any) => boolean, params?: any, handler?: (result: SYSADMIN.matViewStatus_RSParam) => void): $data.IPromise;
    single(predicate: (it: SYSADMIN.matViewStatus_RSParam, params?: any) => boolean, params?: any, handler?: { success?: (result: SYSADMIN.matViewStatus_RSParam[]) => void; error?: (result: any) => void; }): $data.IPromise;

    take(amout: number): SYSADMIN.matViewStatus_RSParamQueryable;
    skip(amout: number): SYSADMIN.matViewStatus_RSParamQueryable;

    order(selector: string): SYSADMIN.matViewStatus_RSParamQueryable;
    orderBy(predicate: (it: SYSADMIN.matViewStatus_RSParam) => any): SYSADMIN.matViewStatus_RSParamQueryable;
    orderByDescending(predicate: (it: SYSADMIN.matViewStatus_RSParam) => any): SYSADMIN.matViewStatus_RSParamQueryable;
    
    first(predicate: (it: SYSADMIN.matViewStatus_RSParam, params?: any) => boolean, params?: any, handler?: (result: SYSADMIN.matViewStatus_RSParam) => void): $data.IPromise;
    first(predicate: (it: SYSADMIN.matViewStatus_RSParam, params?: any) => boolean, params?: any, handler?: { success?: (result: SYSADMIN.matViewStatus_RSParam[]) => void; error?: (result: any) => void; }): $data.IPromise;
    
    include(selector: string): SYSADMIN.matViewStatus_RSParamQueryable;

    removeAll(): $data.IPromise;
    removeAll(handler: (count: number) => void): $data.IPromise;
    removeAll(handler: { success?: (result: number) => void; error?: (result: any) => void; }): $data.IPromise;
  }

  export class SYSADMIN extends $data.EntityContext {
    onReady(handler: (context: SYSADMIN) => void): $data.IPromise;
    MatViews: SYSADMIN.MatViewsSet;
    Triggers: SYSADMIN.TriggersSet;
    VDBResources: SYSADMIN.VDBResourcesSet;
    isLoggable: (loggable: boolean, level: string, context: string, handler?: () => void) => $data.IPromise;
    loadMatView: (schemaName: string, viewName: string, invalidate: boolean, handler?: (result: number) => void) => $data.IPromise;
    logMsg: (logged: boolean, level: string, context: string, msg: $data.Blob, handler?: () => void) => $data.IPromise;
    matViewStatus: { (schemaName: string, viewName: string): SYSADMIN.matViewStatus_RSParamQueryable; (schemaName: string, viewName: string, handler: (result: SYSADMIN.matViewStatus_RSParam[]) => void): $data.IPromise; };
    refreshMatView: (RowsUpdated: number, ViewName: string, Invalidate: boolean, handler?: () => void) => $data.IPromise;
    refreshMatViewRow: (RowsUpdated: number, ViewName: string, Key: $data.Blob, KeyOther: $data.Blob, handler?: () => void) => $data.IPromise;
    setColumnStats: (tableName: string, columnName: string, distinctCount: number, nullCount: number, max: string, min: string, handler?: () => void) => $data.IPromise;
    setProperty: (OldValue: $data.Blob, UID: string, Name: string, Value: $data.Blob, handler?: () => void) => $data.IPromise;
    setTableStats: (tableName: string, cardinality: number, handler?: () => void) => $data.IPromise;
    updateMatView: (schemaName: string, viewName: string, refreshCriteria: string, handler?: (result: number) => void) => $data.IPromise;
    
  }
}

declare module pg_catalog {
  class matpg_datatype extends $data.Entity {
    constructor ();
    constructor (initData: { oid?: number; typname?: string; name?: string; uid?: string; typlen?: number; });
    oid: number;
    typname: string;
    name: string;
    uid: string;
    typlen: number;
    
  }

  export interface matpg_datatypeQueryable extends $data.Queryable {
    filter(predicate:(it: pg_catalog.matpg_datatype) => boolean): pg_catalog.matpg_datatypeQueryable;
    filter(predicate:(it: pg_catalog.matpg_datatype) => boolean, thisArg: any): pg_catalog.matpg_datatypeQueryable;

    map(projection: (it: pg_catalog.matpg_datatype) => any): pg_catalog.matpg_datatypeQueryable;

    length(): $data.IPromise;
    length(handler: (result: number) => void): $data.IPromise;
    length(handler: { success?: (result: number) => void; error?: (result: any) => void; }): $data.IPromise;

    forEach(handler: (it: pg_catalog.matpg_datatype) => void ): $data.IPromise;
    
    toArray(): $data.IPromise;
    toArray(handler: (result: pg_catalog.matpg_datatype[]) => void): $data.IPromise;
    toArray(handler: { success?: (result: pg_catalog.matpg_datatype[]) => void; error?: (result: any) => void; }): $data.IPromise;

    single(predicate: (it: pg_catalog.matpg_datatype, params?: any) => boolean, params?: any, handler?: (result: pg_catalog.matpg_datatype) => void): $data.IPromise;
    single(predicate: (it: pg_catalog.matpg_datatype, params?: any) => boolean, params?: any, handler?: { success?: (result: pg_catalog.matpg_datatype[]) => void; error?: (result: any) => void; }): $data.IPromise;

    take(amout: number): pg_catalog.matpg_datatypeQueryable;
    skip(amout: number): pg_catalog.matpg_datatypeQueryable;

    order(selector: string): pg_catalog.matpg_datatypeQueryable;
    orderBy(predicate: (it: pg_catalog.matpg_datatype) => any): pg_catalog.matpg_datatypeQueryable;
    orderByDescending(predicate: (it: pg_catalog.matpg_datatype) => any): pg_catalog.matpg_datatypeQueryable;
    
    first(predicate: (it: pg_catalog.matpg_datatype, params?: any) => boolean, params?: any, handler?: (result: pg_catalog.matpg_datatype) => void): $data.IPromise;
    first(predicate: (it: pg_catalog.matpg_datatype, params?: any) => boolean, params?: any, handler?: { success?: (result: pg_catalog.matpg_datatype[]) => void; error?: (result: any) => void; }): $data.IPromise;
    
    include(selector: string): pg_catalog.matpg_datatypeQueryable;

    removeAll(): $data.IPromise;
    removeAll(handler: (count: number) => void): $data.IPromise;
    removeAll(handler: { success?: (result: number) => void; error?: (result: any) => void; }): $data.IPromise;
  }


  export interface matpg_datatypeSet extends matpg_datatypeQueryable {
    add(initData: { oid?: number; typname?: string; name?: string; uid?: string; typlen?: number; }): pg_catalog.matpg_datatype;
    add(item: pg_catalog.matpg_datatype): pg_catalog.matpg_datatype;

    attach(item: pg_catalog.matpg_datatype): void;
    attach(item: { oid: number; name: string; }): void;
    attachOrGet(item: pg_catalog.matpg_datatype): pg_catalog.matpg_datatype;
    attachOrGet(item: { oid: number; name: string; }): pg_catalog.matpg_datatype;

    detach(item: pg_catalog.matpg_datatype): void;
    detach(item: { oid: number; name: string; }): void;

    remove(item: pg_catalog.matpg_datatype): void;
    remove(item: { oid: number; name: string; }): void;
    
    elementType: new (initData: { oid?: number; typname?: string; name?: string; uid?: string; typlen?: number; }) => pg_catalog.matpg_datatype;
  }

  class matpg_relatt extends $data.Entity {
    constructor ();
    constructor (initData: { attrelid?: number; attnum?: number; attname?: string; relname?: string; nspname?: string; autoinc?: boolean; typoid?: number; });
    attrelid: number;
    attnum: number;
    attname: string;
    relname: string;
    nspname: string;
    autoinc: boolean;
    typoid: number;
    
  }

  export interface matpg_relattQueryable extends $data.Queryable {
    filter(predicate:(it: pg_catalog.matpg_relatt) => boolean): pg_catalog.matpg_relattQueryable;
    filter(predicate:(it: pg_catalog.matpg_relatt) => boolean, thisArg: any): pg_catalog.matpg_relattQueryable;

    map(projection: (it: pg_catalog.matpg_relatt) => any): pg_catalog.matpg_relattQueryable;

    length(): $data.IPromise;
    length(handler: (result: number) => void): $data.IPromise;
    length(handler: { success?: (result: number) => void; error?: (result: any) => void; }): $data.IPromise;

    forEach(handler: (it: pg_catalog.matpg_relatt) => void ): $data.IPromise;
    
    toArray(): $data.IPromise;
    toArray(handler: (result: pg_catalog.matpg_relatt[]) => void): $data.IPromise;
    toArray(handler: { success?: (result: pg_catalog.matpg_relatt[]) => void; error?: (result: any) => void; }): $data.IPromise;

    single(predicate: (it: pg_catalog.matpg_relatt, params?: any) => boolean, params?: any, handler?: (result: pg_catalog.matpg_relatt) => void): $data.IPromise;
    single(predicate: (it: pg_catalog.matpg_relatt, params?: any) => boolean, params?: any, handler?: { success?: (result: pg_catalog.matpg_relatt[]) => void; error?: (result: any) => void; }): $data.IPromise;

    take(amout: number): pg_catalog.matpg_relattQueryable;
    skip(amout: number): pg_catalog.matpg_relattQueryable;

    order(selector: string): pg_catalog.matpg_relattQueryable;
    orderBy(predicate: (it: pg_catalog.matpg_relatt) => any): pg_catalog.matpg_relattQueryable;
    orderByDescending(predicate: (it: pg_catalog.matpg_relatt) => any): pg_catalog.matpg_relattQueryable;
    
    first(predicate: (it: pg_catalog.matpg_relatt, params?: any) => boolean, params?: any, handler?: (result: pg_catalog.matpg_relatt) => void): $data.IPromise;
    first(predicate: (it: pg_catalog.matpg_relatt, params?: any) => boolean, params?: any, handler?: { success?: (result: pg_catalog.matpg_relatt[]) => void; error?: (result: any) => void; }): $data.IPromise;
    
    include(selector: string): pg_catalog.matpg_relattQueryable;

    removeAll(): $data.IPromise;
    removeAll(handler: (count: number) => void): $data.IPromise;
    removeAll(handler: { success?: (result: number) => void; error?: (result: any) => void; }): $data.IPromise;
  }


  export interface matpg_relattSet extends matpg_relattQueryable {
    add(initData: { attrelid?: number; attnum?: number; attname?: string; relname?: string; nspname?: string; autoinc?: boolean; typoid?: number; }): pg_catalog.matpg_relatt;
    add(item: pg_catalog.matpg_relatt): pg_catalog.matpg_relatt;

    attach(item: pg_catalog.matpg_relatt): void;
    attach(item: { attname: string; relname: string; nspname: string; }): void;
    attachOrGet(item: pg_catalog.matpg_relatt): pg_catalog.matpg_relatt;
    attachOrGet(item: { attname: string; relname: string; nspname: string; }): pg_catalog.matpg_relatt;

    detach(item: pg_catalog.matpg_relatt): void;
    detach(item: { attname: string; relname: string; nspname: string; }): void;

    remove(item: pg_catalog.matpg_relatt): void;
    remove(item: { attname: string; relname: string; nspname: string; }): void;
    
    elementType: new (initData: { attrelid?: number; attnum?: number; attname?: string; relname?: string; nspname?: string; autoinc?: boolean; typoid?: number; }) => pg_catalog.matpg_relatt;
  }

  class pg_attribute extends $data.Entity {
    constructor ();
    constructor (initData: { oid?: number; attrelid?: number; attname?: string; atttypid?: number; attlen?: number; attnum?: number; atttypmod?: number; attnotnull?: boolean; attisdropped?: boolean; atthasdef?: boolean; });
    oid: number;
    attrelid: number;
    attname: string;
    atttypid: number;
    attlen: number;
    attnum: number;
    atttypmod: number;
    attnotnull: boolean;
    attisdropped: boolean;
    atthasdef: boolean;
    
  }

  export interface pg_attributeQueryable extends $data.Queryable {
    filter(predicate:(it: pg_catalog.pg_attribute) => boolean): pg_catalog.pg_attributeQueryable;
    filter(predicate:(it: pg_catalog.pg_attribute) => boolean, thisArg: any): pg_catalog.pg_attributeQueryable;

    map(projection: (it: pg_catalog.pg_attribute) => any): pg_catalog.pg_attributeQueryable;

    length(): $data.IPromise;
    length(handler: (result: number) => void): $data.IPromise;
    length(handler: { success?: (result: number) => void; error?: (result: any) => void; }): $data.IPromise;

    forEach(handler: (it: pg_catalog.pg_attribute) => void ): $data.IPromise;
    
    toArray(): $data.IPromise;
    toArray(handler: (result: pg_catalog.pg_attribute[]) => void): $data.IPromise;
    toArray(handler: { success?: (result: pg_catalog.pg_attribute[]) => void; error?: (result: any) => void; }): $data.IPromise;

    single(predicate: (it: pg_catalog.pg_attribute, params?: any) => boolean, params?: any, handler?: (result: pg_catalog.pg_attribute) => void): $data.IPromise;
    single(predicate: (it: pg_catalog.pg_attribute, params?: any) => boolean, params?: any, handler?: { success?: (result: pg_catalog.pg_attribute[]) => void; error?: (result: any) => void; }): $data.IPromise;

    take(amout: number): pg_catalog.pg_attributeQueryable;
    skip(amout: number): pg_catalog.pg_attributeQueryable;

    order(selector: string): pg_catalog.pg_attributeQueryable;
    orderBy(predicate: (it: pg_catalog.pg_attribute) => any): pg_catalog.pg_attributeQueryable;
    orderByDescending(predicate: (it: pg_catalog.pg_attribute) => any): pg_catalog.pg_attributeQueryable;
    
    first(predicate: (it: pg_catalog.pg_attribute, params?: any) => boolean, params?: any, handler?: (result: pg_catalog.pg_attribute) => void): $data.IPromise;
    first(predicate: (it: pg_catalog.pg_attribute, params?: any) => boolean, params?: any, handler?: { success?: (result: pg_catalog.pg_attribute[]) => void; error?: (result: any) => void; }): $data.IPromise;
    
    include(selector: string): pg_catalog.pg_attributeQueryable;

    removeAll(): $data.IPromise;
    removeAll(handler: (count: number) => void): $data.IPromise;
    removeAll(handler: { success?: (result: number) => void; error?: (result: any) => void; }): $data.IPromise;
  }


  export interface pg_attributeSet extends pg_attributeQueryable {
    add(initData: { oid?: number; attrelid?: number; attname?: string; atttypid?: number; attlen?: number; attnum?: number; atttypmod?: number; attnotnull?: boolean; attisdropped?: boolean; atthasdef?: boolean; }): pg_catalog.pg_attribute;
    add(item: pg_catalog.pg_attribute): pg_catalog.pg_attribute;

    attach(item: pg_catalog.pg_attribute): void;
    attach(item: { oid: number; }): void;
    attachOrGet(item: pg_catalog.pg_attribute): pg_catalog.pg_attribute;
    attachOrGet(item: { oid: number; }): pg_catalog.pg_attribute;

    detach(item: pg_catalog.pg_attribute): void;
    detach(item: { oid: number; }): void;

    remove(item: pg_catalog.pg_attribute): void;
    remove(item: { oid: number; }): void;
    
    elementType: new (initData: { oid?: number; attrelid?: number; attname?: string; atttypid?: number; attlen?: number; attnum?: number; atttypmod?: number; attnotnull?: boolean; attisdropped?: boolean; atthasdef?: boolean; }) => pg_catalog.pg_attribute;
  }

  class pg_class extends $data.Entity {
    constructor ();
    constructor (initData: { oid?: number; relname?: string; relnamespace?: number; relkind?: string; relam?: number; reltuples?: number; relpages?: number; relhasrules?: boolean; relhasoids?: boolean; });
    oid: number;
    relname: string;
    relnamespace: number;
    relkind: string;
    relam: number;
    reltuples: number;
    relpages: number;
    relhasrules: boolean;
    relhasoids: boolean;
    
  }

  export interface pg_classQueryable extends $data.Queryable {
    filter(predicate:(it: pg_catalog.pg_class) => boolean): pg_catalog.pg_classQueryable;
    filter(predicate:(it: pg_catalog.pg_class) => boolean, thisArg: any): pg_catalog.pg_classQueryable;

    map(projection: (it: pg_catalog.pg_class) => any): pg_catalog.pg_classQueryable;

    length(): $data.IPromise;
    length(handler: (result: number) => void): $data.IPromise;
    length(handler: { success?: (result: number) => void; error?: (result: any) => void; }): $data.IPromise;

    forEach(handler: (it: pg_catalog.pg_class) => void ): $data.IPromise;
    
    toArray(): $data.IPromise;
    toArray(handler: (result: pg_catalog.pg_class[]) => void): $data.IPromise;
    toArray(handler: { success?: (result: pg_catalog.pg_class[]) => void; error?: (result: any) => void; }): $data.IPromise;

    single(predicate: (it: pg_catalog.pg_class, params?: any) => boolean, params?: any, handler?: (result: pg_catalog.pg_class) => void): $data.IPromise;
    single(predicate: (it: pg_catalog.pg_class, params?: any) => boolean, params?: any, handler?: { success?: (result: pg_catalog.pg_class[]) => void; error?: (result: any) => void; }): $data.IPromise;

    take(amout: number): pg_catalog.pg_classQueryable;
    skip(amout: number): pg_catalog.pg_classQueryable;

    order(selector: string): pg_catalog.pg_classQueryable;
    orderBy(predicate: (it: pg_catalog.pg_class) => any): pg_catalog.pg_classQueryable;
    orderByDescending(predicate: (it: pg_catalog.pg_class) => any): pg_catalog.pg_classQueryable;
    
    first(predicate: (it: pg_catalog.pg_class, params?: any) => boolean, params?: any, handler?: (result: pg_catalog.pg_class) => void): $data.IPromise;
    first(predicate: (it: pg_catalog.pg_class, params?: any) => boolean, params?: any, handler?: { success?: (result: pg_catalog.pg_class[]) => void; error?: (result: any) => void; }): $data.IPromise;
    
    include(selector: string): pg_catalog.pg_classQueryable;

    removeAll(): $data.IPromise;
    removeAll(handler: (count: number) => void): $data.IPromise;
    removeAll(handler: { success?: (result: number) => void; error?: (result: any) => void; }): $data.IPromise;
  }


  export interface pg_classSet extends pg_classQueryable {
    add(initData: { oid?: number; relname?: string; relnamespace?: number; relkind?: string; relam?: number; reltuples?: number; relpages?: number; relhasrules?: boolean; relhasoids?: boolean; }): pg_catalog.pg_class;
    add(item: pg_catalog.pg_class): pg_catalog.pg_class;

    attach(item: pg_catalog.pg_class): void;
    attach(item: { oid: number; }): void;
    attachOrGet(item: pg_catalog.pg_class): pg_catalog.pg_class;
    attachOrGet(item: { oid: number; }): pg_catalog.pg_class;

    detach(item: pg_catalog.pg_class): void;
    detach(item: { oid: number; }): void;

    remove(item: pg_catalog.pg_class): void;
    remove(item: { oid: number; }): void;
    
    elementType: new (initData: { oid?: number; relname?: string; relnamespace?: number; relkind?: string; relam?: number; reltuples?: number; relpages?: number; relhasrules?: boolean; relhasoids?: boolean; }) => pg_catalog.pg_class;
  }

  class pg_index extends $data.Entity {
    constructor ();
    constructor (initData: { oid?: number; indexrelid?: number; indrelid?: number; indnatts?: number; indisclustered?: boolean; indisunique?: boolean; indisprimary?: boolean; indkey?: Array<number>; indexprs?: string; indpred?: string; });
    oid: number;
    indexrelid: number;
    indrelid: number;
    indnatts: number;
    indisclustered: boolean;
    indisunique: boolean;
    indisprimary: boolean;
    indkey: Array<number>;
    indexprs: string;
    indpred: string;
    
  }

  export interface pg_indexQueryable extends $data.Queryable {
    filter(predicate:(it: pg_catalog.pg_index) => boolean): pg_catalog.pg_indexQueryable;
    filter(predicate:(it: pg_catalog.pg_index) => boolean, thisArg: any): pg_catalog.pg_indexQueryable;

    map(projection: (it: pg_catalog.pg_index) => any): pg_catalog.pg_indexQueryable;

    length(): $data.IPromise;
    length(handler: (result: number) => void): $data.IPromise;
    length(handler: { success?: (result: number) => void; error?: (result: any) => void; }): $data.IPromise;

    forEach(handler: (it: pg_catalog.pg_index) => void ): $data.IPromise;
    
    toArray(): $data.IPromise;
    toArray(handler: (result: pg_catalog.pg_index[]) => void): $data.IPromise;
    toArray(handler: { success?: (result: pg_catalog.pg_index[]) => void; error?: (result: any) => void; }): $data.IPromise;

    single(predicate: (it: pg_catalog.pg_index, params?: any) => boolean, params?: any, handler?: (result: pg_catalog.pg_index) => void): $data.IPromise;
    single(predicate: (it: pg_catalog.pg_index, params?: any) => boolean, params?: any, handler?: { success?: (result: pg_catalog.pg_index[]) => void; error?: (result: any) => void; }): $data.IPromise;

    take(amout: number): pg_catalog.pg_indexQueryable;
    skip(amout: number): pg_catalog.pg_indexQueryable;

    order(selector: string): pg_catalog.pg_indexQueryable;
    orderBy(predicate: (it: pg_catalog.pg_index) => any): pg_catalog.pg_indexQueryable;
    orderByDescending(predicate: (it: pg_catalog.pg_index) => any): pg_catalog.pg_indexQueryable;
    
    first(predicate: (it: pg_catalog.pg_index, params?: any) => boolean, params?: any, handler?: (result: pg_catalog.pg_index) => void): $data.IPromise;
    first(predicate: (it: pg_catalog.pg_index, params?: any) => boolean, params?: any, handler?: { success?: (result: pg_catalog.pg_index[]) => void; error?: (result: any) => void; }): $data.IPromise;
    
    include(selector: string): pg_catalog.pg_indexQueryable;

    removeAll(): $data.IPromise;
    removeAll(handler: (count: number) => void): $data.IPromise;
    removeAll(handler: { success?: (result: number) => void; error?: (result: any) => void; }): $data.IPromise;
  }


  export interface pg_indexSet extends pg_indexQueryable {
    add(initData: { oid?: number; indexrelid?: number; indrelid?: number; indnatts?: number; indisclustered?: boolean; indisunique?: boolean; indisprimary?: boolean; indkey?: Array<number>; indexprs?: string; indpred?: string; }): pg_catalog.pg_index;
    add(item: pg_catalog.pg_index): pg_catalog.pg_index;

    attach(item: pg_catalog.pg_index): void;
    attach(item: { oid: number; }): void;
    attachOrGet(item: pg_catalog.pg_index): pg_catalog.pg_index;
    attachOrGet(item: { oid: number; }): pg_catalog.pg_index;

    detach(item: pg_catalog.pg_index): void;
    detach(item: { oid: number; }): void;

    remove(item: pg_catalog.pg_index): void;
    remove(item: { oid: number; }): void;
    
    elementType: new (initData: { oid?: number; indexrelid?: number; indrelid?: number; indnatts?: number; indisclustered?: boolean; indisunique?: boolean; indisprimary?: boolean; indkey?: Array<number>; indexprs?: string; indpred?: string; }) => pg_catalog.pg_index;
  }

  class pg_proc extends $data.Entity {
    constructor ();
    constructor (initData: { oid?: number; proname?: string; proretset?: boolean; prorettype?: number; pronargs?: number; proargtypes?: Array<number>; proargnames?: Array<string>; proargmodes?: Array<string>; proallargtypes?: Array<number>; pronamespace?: number; });
    oid: number;
    proname: string;
    proretset: boolean;
    prorettype: number;
    pronargs: number;
    proargtypes: Array<number>;
    proargnames: Array<string>;
    proargmodes: Array<string>;
    proallargtypes: Array<number>;
    pronamespace: number;
    
  }

  export interface pg_procQueryable extends $data.Queryable {
    filter(predicate:(it: pg_catalog.pg_proc) => boolean): pg_catalog.pg_procQueryable;
    filter(predicate:(it: pg_catalog.pg_proc) => boolean, thisArg: any): pg_catalog.pg_procQueryable;

    map(projection: (it: pg_catalog.pg_proc) => any): pg_catalog.pg_procQueryable;

    length(): $data.IPromise;
    length(handler: (result: number) => void): $data.IPromise;
    length(handler: { success?: (result: number) => void; error?: (result: any) => void; }): $data.IPromise;

    forEach(handler: (it: pg_catalog.pg_proc) => void ): $data.IPromise;
    
    toArray(): $data.IPromise;
    toArray(handler: (result: pg_catalog.pg_proc[]) => void): $data.IPromise;
    toArray(handler: { success?: (result: pg_catalog.pg_proc[]) => void; error?: (result: any) => void; }): $data.IPromise;

    single(predicate: (it: pg_catalog.pg_proc, params?: any) => boolean, params?: any, handler?: (result: pg_catalog.pg_proc) => void): $data.IPromise;
    single(predicate: (it: pg_catalog.pg_proc, params?: any) => boolean, params?: any, handler?: { success?: (result: pg_catalog.pg_proc[]) => void; error?: (result: any) => void; }): $data.IPromise;

    take(amout: number): pg_catalog.pg_procQueryable;
    skip(amout: number): pg_catalog.pg_procQueryable;

    order(selector: string): pg_catalog.pg_procQueryable;
    orderBy(predicate: (it: pg_catalog.pg_proc) => any): pg_catalog.pg_procQueryable;
    orderByDescending(predicate: (it: pg_catalog.pg_proc) => any): pg_catalog.pg_procQueryable;
    
    first(predicate: (it: pg_catalog.pg_proc, params?: any) => boolean, params?: any, handler?: (result: pg_catalog.pg_proc) => void): $data.IPromise;
    first(predicate: (it: pg_catalog.pg_proc, params?: any) => boolean, params?: any, handler?: { success?: (result: pg_catalog.pg_proc[]) => void; error?: (result: any) => void; }): $data.IPromise;
    
    include(selector: string): pg_catalog.pg_procQueryable;

    removeAll(): $data.IPromise;
    removeAll(handler: (count: number) => void): $data.IPromise;
    removeAll(handler: { success?: (result: number) => void; error?: (result: any) => void; }): $data.IPromise;
  }


  export interface pg_procSet extends pg_procQueryable {
    add(initData: { oid?: number; proname?: string; proretset?: boolean; prorettype?: number; pronargs?: number; proargtypes?: Array<number>; proargnames?: Array<string>; proargmodes?: Array<string>; proallargtypes?: Array<number>; pronamespace?: number; }): pg_catalog.pg_proc;
    add(item: pg_catalog.pg_proc): pg_catalog.pg_proc;

    attach(item: pg_catalog.pg_proc): void;
    attach(item: { oid: number; }): void;
    attachOrGet(item: pg_catalog.pg_proc): pg_catalog.pg_proc;
    attachOrGet(item: { oid: number; }): pg_catalog.pg_proc;

    detach(item: pg_catalog.pg_proc): void;
    detach(item: { oid: number; }): void;

    remove(item: pg_catalog.pg_proc): void;
    remove(item: { oid: number; }): void;
    
    elementType: new (initData: { oid?: number; proname?: string; proretset?: boolean; prorettype?: number; pronargs?: number; proargtypes?: Array<number>; proargnames?: Array<string>; proargmodes?: Array<string>; proallargtypes?: Array<number>; pronamespace?: number; }) => pg_catalog.pg_proc;
  }

  export class pg_catalog extends $data.EntityContext {
    onReady(handler: (context: pg_catalog) => void): $data.IPromise;
    matpg_datatype: pg_catalog.matpg_datatypeSet;
    matpg_relatt: pg_catalog.matpg_relattSet;
    pg_attribute: pg_catalog.pg_attributeSet;
    pg_class: pg_catalog.pg_classSet;
    pg_index: pg_catalog.pg_indexSet;
    pg_proc: pg_catalog.pg_procSet;
    
  }
}
